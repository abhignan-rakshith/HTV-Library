<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hanime.tv Library</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <webview
      id="webview"
      src="https://hanime.tv"
      allowfullscreen
      webpreferences="allowRunningInsecureContent, javascript=yes"
      useragent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"
      partition="persist:main"
      httpreferrer="https://hanime.tv"
    ></webview>
    <button id="fab" class="floating-action-button" title="Library">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
        <path fill="none" d="M0 0h24v24H0z"/>
        <path d="M4 4c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2v16c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V4zm2 0v16h12V4H6z" fill="currentColor"/>
        <path d="M8 5h8v2H8zM8 9h8v2H8zM8 13h8v2H8z" fill="currentColor"/>
      </svg>
    </button>
    <div id="snackbar" class="snackbar"></div>
    
    <!-- Popup Modal to Display Scraped Data -->
    <div id="dataModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Media Details</h2>
          <button id="closeModal" class="close-button">&times;</button>
        </div>
        <table class="data-table">
          <tr>
            <td>Title</td>
            <td><input type="text" id="titleField" class="data-field" readonly></td>
          </tr>
          <tr>
            <td>Views</td>
            <td><input type="text" id="viewsField" class="data-field" readonly></td>
          </tr>
          <tr>
            <td>URL</td>
            <td><input type="text" id="urlField" class="data-field" readonly></td>
          </tr>
          <tr>
            <td>Thumbnail</td>
            <td>
              <img id="thumbnailPreview" class="data-thumbnail" src="" alt="Thumbnail preview">
              <input type="text" id="thumbnailField" class="data-field" readonly>
            </td>
          </tr>
          <tr>
            <td>Brand</td>
            <td><input type="text" id="brandField" class="data-field" readonly></td>
          </tr>
          <tr>
            <td>Release Date</td>
            <td><input type="text" id="releaseDateField" class="data-field" readonly></td>
          </tr>
          <tr>
            <td>Tags</td>
            <td><div id="tagsContainer" class="tags-container"></div></td>
          </tr>
          <tr>
            <td>Plot</td>
            <td><textarea id="plotField" class="data-field" rows="6"></textarea></td>
          </tr>
        </table>
        <div class="action-buttons">
          <button id="cancelButton" class="action-button cancel-button">Cancel</button>
          <button id="saveButton" class="action-button save-button">Save to Library</button>
        </div>
      </div>
    </div>      <script>
      const webview = document.getElementById('webview');
      const fab = document.getElementById('fab');
      const snackbar = document.getElementById('snackbar');
      const dataModal = document.getElementById('dataModal');
      const closeModal = document.getElementById('closeModal');
      const cancelButton = document.getElementById('cancelButton');
      const saveButton = document.getElementById('saveButton');

      // Fields in the popup
      const titleField = document.getElementById('titleField');
      const viewsField = document.getElementById('viewsField');
      const urlField = document.getElementById('urlField');
      const thumbnailField = document.getElementById('thumbnailField');
      const thumbnailPreview = document.getElementById('thumbnailPreview');
      const brandField = document.getElementById('brandField');
      const releaseDateField = document.getElementById('releaseDateField');
      const tagsContainer = document.getElementById('tagsContainer');
      const plotField = document.getElementById('plotField');

      // Current scraped data
      let currentScrapedData = null;

      // Forward all console messages from webview to main window
      webview.addEventListener('console-message', (e) => {
        console.log('Webview console:', e.message);
      });

      // Enable debugging features
      webview.addEventListener('dom-ready', () => {
        // Force enable DevTools for webview
        webview.openDevTools();
        console.log('Webview ready, DevTools enabled');
      });

      // Log to both console and debug file
      function debugLog(message, data = '') {
        const logMessage = `${new Date().toISOString()} - ${message}${data ? ': ' + JSON.stringify(data, null, 2) : ''}\n`;
        console.log(logMessage);
        
        // Send the log message to the main process to save to file
        window.electron.send('debug-log', logMessage);
      }

      function showSnackbar(message) {
        snackbar.textContent = message;
        snackbar.classList.add('show');
        setTimeout(() => {
          snackbar.classList.remove('show');
        }, 1500);
      }      async function scrapeVideoPage() {
        try {
          console.log('ðŸ” Starting page scrape...');
          showSnackbar('Starting scrape...');
          
          // Execute JavaScript in the webview context to get the page data
          const pageData = await webview.executeJavaScript(`
            (function() {
              console.log('Inside webview context');
              
              try {
                // Log each element as we find it
                const title = document.querySelector('.tv-title');
                console.log('Title element:', title?.textContent);
                
                const views = document.querySelector('.tv-views');
                console.log('Views element:', views?.textContent);
                
                const thumbnail = document.querySelector('.hvpi-cover');
                console.log('Thumbnail element:', thumbnail?.src);
                
                const brand = document.querySelector('.hvpimbc-text[href*="/browse/brands/"]');
                console.log('Brand element:', brand?.textContent);
                
                // Find release date by looking through all hvpimbc-item elements
                let releaseDate = null;
                document.querySelectorAll('.hvpimbc-item').forEach(item => {
                  const header = item.querySelector('.hvpimbc-header');
                  if (header && header.textContent.includes('Release Date')) {
                    releaseDate = item.querySelector('.hvpimbc-text');
                  }
                });
                console.log('Release date element:', releaseDate?.textContent);                // Get the current page URL without query parameters
                let currentUrl = window.location.href;
                // Remove query parameters like ?playlist_id
                currentUrl = currentUrl.split('?')[0];
                console.log('Current URL:', currentUrl);
                
                // Get tags from the tag links - using more general selector and limiting to first 10
                let tagTexts = [];
                try {
                  // Only get tags from the first set of tag links (in the hvpis-text section)
                  const tagLinks = document.querySelectorAll('.hvpis-text a[href^="/browse/tags/"]');
                  console.log('Found tag elements:', tagLinks.length);
                  
                  if (tagLinks.length > 0) {
                    // Extract tags, decode URL entities, remove duplicates, and limit to first 10
                    tagTexts = [...new Set(
                      Array.from(tagLinks)
                        .slice(0, 10) // Limit to first 10 tag links
                        .map(link => {
                          const href = link.getAttribute('href');
                          if (href) {
                            const tag = href.split('/browse/tags/')[1];
                            return decodeURIComponent(tag);
                          } else {
                            // Fallback to button content
                            const content = link.querySelector('.btn__content');
                            return content ? content.textContent.trim() : null;
                          }
                        })
                        .filter(Boolean)
                    )];
                  }
                } catch (tagError) {
                  console.error('Error extracting tags:', tagError);
                  tagTexts = [];
                }
                
                console.log('Tags found:', tagTexts.length);
                console.log('Tag list:', tagTexts);
                
                const plot = document.querySelector('.hvpist-description');
                console.log('Plot element:', plot?.textContent);
                
                // Extract just the numeric view count and convert to integer
                let viewCount = null;
                if (views && views.textContent) {
                  const cleanViews = views.textContent.trim().split(' ')[0].replace(/,/g, '');
                  viewCount = parseInt(cleanViews, 10);
                }
                  const data = {
                  url: currentUrl,
                  title: title?.textContent?.trim(),
                  views: viewCount,
                  thumbnail: thumbnail?.src,
                  brand: brand?.textContent?.trim(),
                  releaseDate: releaseDate?.textContent?.trim(),
                  tags: tagTexts,
                  plot: plot?.textContent?.trim()
                };console.log('Collected data:', data);

                // Check if all elements were found
                const missingElements = [];
                Object.entries(data).forEach(([key, value]) => {
                  if (!value || (Array.isArray(value) && value.length === 0)) {
                    missingElements.push(key);
                  }
                });

                console.log('Missing elements:', missingElements);

                return {
                  found: missingElements.length === 0,
                  missingElements,
                  data
                };
              } catch (error) {
                console.error('Error during scraping:', error);
                return {
                  found: false,
                  error: error.message,
                  data: {}
                };
              }
            })();
          `);

          console.log('ðŸ“„ Scraping results:', pageData);
          
          // Write to console in a more readable format
          console.log('\n=== SCRAPED DATA ===');
          if (pageData && pageData.data) {
            Object.entries(pageData.data).forEach(([key, value]) => {
              console.log(key + ':', value);
            });
          }
          console.log('===================\n');          if (pageData.found) {
            showSnackbar('Found all required elements!');
            
            // Save the current data
            currentScrapedData = pageData.data;
            
            // Populate the modal fields with the scraped data
            titleField.value = pageData.data.title || '';
            viewsField.value = pageData.data.views !== null ? pageData.data.views.toLocaleString() : '';
            urlField.value = pageData.data.url || '';
            thumbnailField.value = pageData.data.thumbnail || '';
            
            // Set thumbnail preview
            if (pageData.data.thumbnail) {
              thumbnailPreview.src = pageData.data.thumbnail;
              thumbnailPreview.style.display = 'block';
            } else {
              thumbnailPreview.style.display = 'none';
            }
            
            brandField.value = pageData.data.brand || '';
            releaseDateField.value = pageData.data.releaseDate || '';
            plotField.value = pageData.data.plot || '';

            // Clear existing tags
            tagsContainer.innerHTML = '';

            // Add each tag as a tag
            if (pageData.data.tags && pageData.data.tags.length > 0) {
              pageData.data.tags.forEach(tag => {
                const tagElement = document.createElement('div');
                tagElement.className = 'tag';
                tagElement.textContent = tag;
                tagsContainer.appendChild(tagElement);
              });
            }

            // Show the modal with the scraped data
            dataModal.style.display = 'block';
          } else {
            showSnackbar('Missing elements: ' + pageData.missingElements.join(', '));
          }

          return pageData;
        } catch (error) {
          console.error('Error scraping page:', error);
          showSnackbar('Error scraping page content');
        }
      }

      fab.addEventListener('click', async () => {
        const currentUrl = webview.getURL();
        
        if (currentUrl.includes('/videos/hentai/')) {
          showSnackbar('Scraping page content...');
          await scrapeVideoPage();
        } else if (currentUrl.includes('/browse/images')) {
          showSnackbar('Adding to library...');
          // TODO: Implement images library functionality
        } else {
          showSnackbar('Please navigate to a media page!');
        }
      });      // Close modal when clicking outside of it
      window.addEventListener('click', (event) => {
        if (event.target === dataModal) {
          dataModal.style.display = 'none';
        }
      });
      
      // Close button event
      closeModal.addEventListener('click', () => {
        dataModal.style.display = 'none';
      });
      
      // Cancel button event
      cancelButton.addEventListener('click', () => {
        dataModal.style.display = 'none';
      });
      
      // Save button event
      saveButton.addEventListener('click', () => {
        if (currentScrapedData) {
          // Update the plot with any edited content
          currentScrapedData.plot = plotField.value;
          
          // Here we'll later add code to save to a database/file
          console.log('Saving to library:', currentScrapedData);
          showSnackbar('Saved to library!');
          
          // Close the modal after saving
          dataModal.style.display = 'none';
        }
      });

      // Close modal when clicking the close button
      closeModal.addEventListener('click', () => {
        dataModal.style.display = 'none';
      });

      cancelButton.addEventListener('click', () => {
        dataModal.style.display = 'none';
      });

      saveButton.addEventListener('click', () => {
        // TODO: Implement save to library functionality
        showSnackbar('Save to library functionality not implemented yet');
      });
    </script>
  </body>
</html>
